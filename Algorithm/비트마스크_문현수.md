# 비트마스크

## 비트마스크

- 이진수를 사용하는 컴퓨터의 연산 방식을 활용하여 정수의 이진수 표현을 자료 구조로 사용하는 기법
- 0과 1로 표현하기 때문에 하나의 비트로는 켜져있다/ 꺼져있다로 표현 가능

## 비트마스크의 장점

1. 수행시간이 빠르다.

- 다른 자료구조를 이용하는 것보다 훨씬 빠르게 동작
- 연산 횟수가 늘어남에 따라서 속도의 차가 매우 커지게 됨
  (비트연산은 시간복잡도 O(1)이기 때문에)

2. 코드가 짧다.

- 다양한 연산을 비트연산 한 줄로 작성가능

3. 메모리 사용량이 더 적다.

```
EX) bit가 10인 경우 2^10 가지의 경우의 수
-> bit 하나로 여러개의 경우를 표현할 수 있기 때문에 메모리 측면에서 효율적
```

## 비트 연산자

- 비트 마스크를 이용하기 위해서, 정수 변수를 비트 별로 조작할 수 있는 비트 연산자를 사용
- 두 정수 또는 하나의 정수를 이용하여 새로운 값을 생성

1. AND 연산

- 정수 변수 a,b를 통해서 c를 생성
- a,b를 비교해서 해당 비트들이 전부 켜져 있는 경우에만 c의 비트를 활성화
  (켜져있다 = 1)

```
c = a & b

100111001011010100111010 & 010110100001101111011000 = 000110000001000100011000
```

2. OR 연산

- a,b 비트에서 둘 중 하나라도 켜져 있는 경우에만 c의 비트를 켬

```
c = a | b

1111^0110 = 1111
```

3. XOR 연산

- a,b 비트에서 둘 중 하나'만' 켜져 있는 경우에만 c의 비트를 켬

```
c = a^b

1111^0110 = 1001
```

4. NOT 연산

- 정수 변수 하나를 입력받아서, 켜져있는 비트는 끄고, 꺼져있는 비트는 킨 결과를 반환

```
~a

~10110 = 01001
```

5. SHIFT 연산

- 정수 a의 비트를 왼쪽 또는 오른 쪽으로 원하는 만큼 움직이고, 빈자리는 0으로 채움
- <<(왼쪽으로 이동) / >>(오른쪽으로 이동)

```
c = a << 1

110011 >> 1 = 011001
```

## 비트 연산자 사용시 주의사항

- 비트 연산자들의 우선순위는 비교연산자보다 낮다.

```
c = (6 & 4 == 4)
4 == 4가 먼저 계산되어 1을 반환, c에는 6 & 1의 값이 할당
```

따라서 연산자마다 괄호를 씌워주는 것이 바람직

- 오버플로우 문제
  2^50을 구하기 위해서는 1<<50으로 표현해야 하지만
  1의 경우에는 32bit 상수취급하기 때문에 50번 왼쪽으로 이동하면 overflow가 발생

## 비트마스크를 이용한 집합 구현

- 하나의 bit가 하나의 원소
- bit = 1 해당 원소가 집합에 포함되어 있다는 의미
- N 비트 정수 변수 = N개의 원소를 갖는 집합 부분의 부분집합들을 모두 표현할 수 있음

#### 가정 : A는 집합, 집합의 총원소 개수는 10개(10비트)

1. 공집합과 꽉찬 집합

공집합의 경우 : 0
꽉 찬 집합의 경우 : 1111111111(2)
(1<<10) -1 과 동일

2. 원소 추가

- 원소에 해당하는 bit 만 켜야하기 때문에 bit를 1로 만드는 연산이 필요 OR 연산을 이용

3. 원소 삭제

- bit를 0으로 만드는 연산 필요
- A -= (1<<k)

4. 원소의 포함여부 확인

- k번쨍 bit가 1인지만 확인

5. 원소의 토글

- XOR 연산 이용

6. 집합의 크기 구하기

- 수제로 비트 크기 확인하면서 개수 체크 OR 내장 명령어 사용
